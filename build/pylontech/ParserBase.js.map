{
  "version": 3,
  "sources": ["../../src/pylontech/ParserBase.ts"],
  "sourcesContent": ["//const debugApi = Debug(\"pylontech:api\");\n\nimport { ConvertValue } from './ConvertValue';\nimport { IParser } from './IParser';\n\nabstract class ParserBase implements IParser {\n  protected _number: number | undefined;\n  protected _convertValue: ConvertValue = new ConvertValue();\n  protected _noConvertKeys: string[] = [];\n  protected _filterKeys: string[] = ['voltage', 'battery', 'power'];\n\n  protected _isParser(data: string, prompt: RegExp, command: string): boolean {\n    const cmd: RegExpExecArray | null = prompt.exec(data);\n    this._number = cmd !== null ? parseInt(cmd[3]) : undefined;\n    return this._number !== undefined && cmd !== null && cmd[2] === command;\n  }\n\n  protected _parseDataHeadlineN(data: string, row: RegExp, command: string, identColumn: number): any {\n    const head: RegExpExecArray | null = row.exec(data);\n    let result: any = {};\n    if (head !== null) {\n      for (let i: number = 1; i < head.length; i++) {\n        head[i] = head[i] ? head[i].trim() : '-X-';\n      }\n      result[command] = {};\n      for (let match: RegExpExecArray | null; (match = row.exec(data)) !== null; ) {\n        const dat: any = {};\n        for (let i: number = 1; i < match.length; i++) {\n          if (match[i]) {\n            dat[head[i] !== null ? head[i] : '-X-'] = match[i].trim();\n          }\n        }\n        if (match[identColumn]) {\n          result[command][match[identColumn].trim()] = dat;\n        }\n      }\n    }\n    if (this._number) {\n      const res: any = {};\n      res[this._number] = result;\n      result = res;\n    }\n    return this._processDatatypes(result);\n  }\n\n  protected _parseDataNameValN(data: string, row: RegExp, command: string): any {\n    let result: any = {};\n    result = {};\n    result[command] = {};\n    for (let match; (match = row.exec(data)) !== null; ) {\n      if (match !== null) {\n        result[command][match[1] === '' ? '-X-' : match[1].trim()] = match[2].trim();\n      }\n    }\n    if (this._number) {\n      const res: any = {};\n      res[this._number] = result;\n      result = res;\n    }\n    return this._processDatatypes(result);\n  }\n\n  protected _parseNameValMultiData(data: string, row: RegExp, command: string, indexColum: string): any {\n    const result: any = {};\n    result[command] = {};\n    let index: number = NaN;\n    for (let match; (match = row.exec(data)) !== null; ) {\n      if (match !== null) {\n        const col: string = match[1] === '' ? '-X-' : match[1].trim();\n        if (col === indexColum) {\n          index = parseInt(match[2]);\n          result[command][index] = {};\n        }\n        if (!isNaN(index)) {\n          result[command][index][col] = match[2].trim();\n        }\n      }\n    }\n    return this._processDatatypes(result);\n  }\n\n  protected _processDatatypes(data: any): any {\n    const result: any = {};\n    Object.keys(data).forEach((key: string) => {\n      if (typeof data[key] === 'object') {\n        result[key] = this._processDatatypes(data[key]);\n      } else {\n        const newKey = key.replaceAll('.', '').replaceAll(' ', '_').replaceAll('__', '_').toLowerCase();\n        if (data[key] !== '-' && !this._filterKeys.includes(newKey)) {\n          result[newKey] = this._convertValue.parseValues(key, data[key], this._noConvertKeys);\n        }\n      }\n    });\n    return result;\n  }\n\n  abstract isParser(data: string): boolean;\n\n  abstract parseData(data: string): object;\n\n  getParserName(): string {\n    return (<any>this).constructor.name;\n  }\n}\nexport = ParserBase;\n"],
  "mappings": "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",
  "names": []
}
