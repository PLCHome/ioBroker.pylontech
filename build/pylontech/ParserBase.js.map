{
  "version": 3,
  "sources": ["../../src/pylontech/ParserBase.ts"],
  "sourcesContent": ["// Copyright (c) 2020-2023 Tr\u00E4ger\n\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the \"Software\"),\n// to deal in the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n// DEALINGS IN THE SOFTWARE.\n\nimport { ConvertValue } from './ConvertValue';\nimport { IParser } from './IParser';\n\nabstract class ParserBase implements IParser {\n  protected _number: number | undefined;\n  protected _convertValue: ConvertValue = new ConvertValue();\n  protected _noConvertKeys: string[] = [];\n  protected _filterKeys: string[] = ['voltage', 'battery', 'power'];\n\n  protected _isParser(cmd: string, prompt: RegExp, command: string): boolean {\n    const cmdParsed: RegExpExecArray | null = prompt.exec(cmd);\n    this._number = cmdParsed !== null ? parseInt(cmdParsed[2]) : undefined;\n    return this._number !== undefined && cmdParsed !== null && cmdParsed[1] === command;\n  }\n\n  protected _parseDataHeadlineN(data: string, row: RegExp, command: string, identColumn: number): any {\n    const head: RegExpExecArray | null = row.exec(data);\n    let result: any = {};\n    let lasthead: string = '-X-';\n    if (head !== null) {\n      for (let i: number = 1; i < head.length; i++) {\n        head[i] = !head[i] || head[i].trim() == '' ? `${lasthead}_` : head[i].trim();\n        lasthead = head[i];\n      }\n      result[command] = {};\n      for (let match: RegExpExecArray | null; (match = row.exec(data)) !== null; ) {\n        const dat: any = {};\n        for (let i: number = 1; i < match.length; i++) {\n          if (match[i]) {\n            dat[head[i] !== null ? head[i] : `${lasthead}_`] = match[i].trim();\n            lasthead = head[i];\n          }\n        }\n        if (identColumn > 0) {\n          if (match[identColumn]) {\n            result[command][match[identColumn].trim()] = dat;\n          }\n        } else {\n          result[command] = dat;\n        }\n      }\n    }\n    if (this._number) {\n      const res: any = {};\n      res[this._number] = result;\n      result = res;\n    }\n    return this._processDatatypes(result);\n  }\n\n  protected _parseDataNameValN(data: string, row: RegExp, command: string): any {\n    let result: any = {};\n    result = {};\n    result[command] = {};\n    let lasthead: string = '-X-';\n    for (let match; (match = row.exec(data)) !== null; ) {\n      if (match !== null) {\n        lasthead = match[1] && match[1].trim() !== '' ? match[1].trim() : `${lasthead}_`;\n        result[command][lasthead] = match[2].trim();\n      }\n    }\n    if (this._number) {\n      const res: any = {};\n      res[this._number] = result;\n      result = res;\n    }\n    return this._processDatatypes(result);\n  }\n\n  protected _parseNameValMultiData(data: string, row: RegExp, command: string, indexColum: string): any {\n    const result: any = {};\n    result[command] = {};\n    let index: number = NaN;\n    let lasthead: string = '-X-';\n    for (let match; (match = row.exec(data)) !== null; ) {\n      if (match !== null) {\n        const col: string = match[1].trim() === '' ? `${lasthead}_` : match[1].trim();\n        lasthead = match[1].trim();\n        if (col === indexColum) {\n          index = parseInt(match[2]);\n          result[command][index] = {};\n        }\n        if (!isNaN(index)) {\n          result[command][index][col] = match[2].trim();\n        }\n      }\n    }\n    return this._processDatatypes(result);\n  }\n\n  protected _processDatatypes(data: any): any {\n    const result: any = {};\n    Object.keys(data).forEach((key: string) => {\n      if (typeof data[key] === 'object') {\n        result[key] = this._processDatatypes(data[key]);\n      } else {\n        const newKey = key.replaceAll('>', '').replaceAll('.', '').replaceAll(' ', '_').replaceAll('__', '_').toLowerCase();\n        if (data[key] !== '-' && !this._filterKeys.includes(newKey)) {\n          result[newKey] = this._convertValue.parseValues(key, data[key], this._noConvertKeys);\n        }\n      }\n    });\n    return result;\n  }\n\n  abstract isParser(data: string): boolean;\n\n  abstract parseData(data: string): object;\n\n  getParserName(): string {\n    return (<any>this).constructor.name;\n  }\n}\nexport = ParserBase;\n"],
  "mappings": "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",
  "names": []
}
