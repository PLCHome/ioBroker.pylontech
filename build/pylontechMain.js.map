{
  "version": 3,
  "sources": ["../src/pylontechMain.ts"],
  "sourcesContent": ["import * as utils from '@iobroker/adapter-core';\nimport { SerialPort } from 'serialport';\nimport { Value } from './pylontech/Value';\nimport WorkerAbstract from './pylontech/WorkerAbstract';\nimport WorkerNet from './pylontech/WorkerNet';\nimport WorkerSerial from './pylontech/WorkerSerial';\n\nclass Pylontech extends utils.Adapter {\n  workTimer: NodeJS.Timeout | undefined;\n\n  public constructor(options: Partial<utils.AdapterOptions> = {}) {\n    super({\n      ...options,\n      name: 'pylontech',\n    });\n    this.on('ready', this.onReady.bind(this));\n    //this.on(\"stateChange\", this.onStateChange.bind(this));\n    // this.on(\"objectChange\", this.onObjectChange.bind(this));\n    this.on('message', this.onMessage.bind(this));\n    this.on('unload', this.onUnload.bind(this));\n  }\n\n  /**\n   * Is called when databases are connected and adapter received configuration.\n   */\n  private async onReady(): Promise<void> {\n    // Initialize your adapter here\n\n    // Reset the connection indicator during startup\n    this.setState('info.connection', false, true);\n\n    // this.subscribeStates('testVariable');\n    // You can also add a subscription for multiple states. The following line watches all states starting with \"lights.\"\n    // this.subscribeStates(\"lights.*\");\n    // Or, if you really must, you can also watch all states. Don't do this if you don't need to. Otherwise this will cause a lot of unnecessary load on the system:\n    // this.subscribeStates(\"*\");\n\n    if (typeof this.config.connection == 'undefined') this.config.connection = '1';\n    if (typeof this.config.baudrate == 'undefined') this.config.baudrate = 115200;\n    if (typeof this.config.rfc2217 == 'undefined') this.config.rfc2217 = false;\n    if (typeof this.config.netbaudrate == 'undefined') this.config.netbaudrate = 115200;\n    if (typeof this.config.info == 'undefined') this.config.info = true;\n    if (typeof this.config.power == 'undefined') this.config.power = true;\n    if (typeof this.config.statistic == 'undefined') this.config.statistic = true;\n    if (typeof this.config.celldata == 'undefined') this.config.celldata = true;\n    if (typeof this.config.cellsoh == 'undefined') this.config.cellsoh = true;\n    if (typeof this.config.log == 'undefined') this.config.log = true;\n    if (typeof this.config.cycle == 'undefined') this.config.cycle = 5;\n\n    this.onTimer();\n    this.workTimer = setInterval(this.onTimer.bind(this), this.config.cycle * 60000);\n  }\n\n  onMessage(obj: any): void {\n    let wait = false;\n    this.log.debug(JSON.stringify(obj));\n    if (obj) {\n      switch (obj.command) {\n        case 'getDevices':\n          wait = true;\n          SerialPort.list().then(port => {\n            const ports: string[] = [];\n            port.forEach(p => {\n              ports.push(p.path);\n            });\n            this.sendTo(obj.from, obj.command, JSON.stringify(ports), obj.callback);\n          });\n          break;\n        default:\n          this.log.warn(`Unknown command: ${obj.command}`);\n          return;\n      }\n    }\n    if (!wait && obj.callback) {\n      this.sendTo(obj.from, obj.command, obj.message, obj.callback);\n    }\n    return;\n  }\n\n  private onTimer(): void {\n    try {\n      const worker: WorkerAbstract =\n        this.config.connection == '1'\n          ? new WorkerSerial(this.config.device, this.config.baudrate)\n          : new WorkerNet(this.config.host, this.config.port, this.config.netbaudrate, this.config.rfc2217);\n\n      worker\n        .getData({\n          info: this.config.info,\n          power: this.config.power,\n          statistic: this.config.statistic,\n          celldata: this.config.celldata,\n          cellsoh: this.config.cellsoh,\n          log: this.config.log,\n        })\n        .then((allData: any) => {\n          worker.close();\n          this.setState('info.connection', true, true);\n          const walk = async (path: string, val: any): Promise<void> => {\n            if (val instanceof Value) {\n              const objdesc: any = {\n                type: 'state',\n                common: {\n                  name: val.name,\n                  type: 'number',\n                  role: 'value',\n                  read: true,\n                  write: val.write,\n                },\n                native: {},\n              };\n              if (val.unit) objdesc.common.unit = val.unit;\n              if (val.function) objdesc.native.function = val.function;\n              switch (val.type) {\n                case 'date':\n                  objdesc.common.role = 'value.time';\n                  break;\n                case 'boolean':\n                case 'string':\n                  objdesc.common.type = val.type;\n                  break;\n              }\n              await this.setObjectNotExistsAsync(path, objdesc);\n              this.setStateAsync(path, val.value, true);\n            } else {\n              let p = '';\n              if (path !== '') p = '.';\n              Object.keys(val).forEach(key => {\n                walk(`${path}${p}${key}`, val[key]);\n              });\n            }\n          };\n          walk('', allData);\n          this.getStatesAsync('info.*.connected').then(state => {\n            Object.keys(state).forEach(path => {\n              const info = path.split('.');\n              this.log.info(info[3]);\n              this.log.info(\n                `${allData.info && allData.info[info[3]] && allData.info[info[3]].connected} ${allData.info && allData.info[info[3]]} ${allData.info}`\n              );\n              if (!(allData.info && allData.info[info[3]] && allData.info[info[3]].connected)) {\n                this.setStateAsync(path, false, true);\n              }\n            });\n          });\n        })\n        .catch(this.log.error);\n    } catch (e) {\n      this.log.error((e as Error).message);\n    }\n  }\n\n  /**\n   * Is called when adapter shuts down - callback has to be called under any circumstances!\n   */\n  private onUnload(callback: () => void): void {\n    try {\n      clearTimeout(this.workTimer);\n      // Here you must clear all timeouts or intervals that may still be active\n      // clearTimeout(timeout1);\n      // clearTimeout(timeout2);\n      // ...\n      // clearInterval(interval1);\n\n      callback();\n    } catch (e) {\n      callback();\n    }\n  }\n\n  // If you need to react to object changes, uncomment the following block and the corresponding line in the constructor.\n  // You also need to subscribe to the objects with `this.subscribeObjects`, similar to `this.subscribeStates`.\n  // /**\n  //  * Is called if a subscribed object changes\n  //  */\n  // private onObjectChange(id: string, obj: ioBroker.Object | null | undefined): void {\n  //     if (obj) {\n  //         // The object was changed\n  //         this.log.info(`object ${id} changed: ${JSON.stringify(obj)}`);\n  //     } else {\n  //         // The object was deleted\n  //         this.log.info(`object ${id} deleted`);\n  //     }\n  // }\n\n  /**\n   * Is called if a subscribed state changes\n   */\n  /*\n    private onStateChange(id: string, state: ioBroker.State | null | undefined): void {\n        if (state) {\n            // The state was changed\n            this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n        } else {\n            // The state was deleted\n            this.log.info(`state ${id} deleted`);\n        }\n    }\n    */\n\n  // If you need to accept messages in your adapter, uncomment the following block and the corresponding line in the constructor.\n  // /**\n  //  * Some message was sent to this instance over message box. Used by email, pushover, text2speech, ...\n  //  * Using this method requires \"common.messagebox\" property to be set to true in io-package.json\n  //  */\n  // private onMessage(obj: ioBroker.Message): void {\n  //     if (typeof obj === \"object\" && obj.message) {\n  //         if (obj.command === \"send\") {\n  //             // e.g. send email or pushover or whatever\n  //             this.log.info(\"send command\");\n\n  //             // Send response in callback if required\n  //             if (obj.callback) this.sendTo(obj.from, obj.command, \"Message received\", obj.callback);\n  //         }\n  //     }\n  // }\n}\n\nif (require.main !== module) {\n  // Export the constructor in compact mode\n  module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new Pylontech(options);\n} else {\n  // otherwise start the instance directly\n  (() => new Pylontech())();\n}\n"],
  "mappings": "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",
  "names": ["WorkerSerial", "WorkerNet"]
}
